# 233-数字1的个数

难度 困难



## 题目描述

给定一个整数 `n`，计算所有小于等于 `n` 的非负整数中数字 `1` 出现的个数。

示例 1：
```
输入：n = 13
输出：6
```
示例 2：
```
输入：n = 0
输出：0
```

提示：

- `0 <= n <= 2 * 10^9`



## 思路

设 N = `abcde` ,其中`abcde`分别为各位上的数字。

如果要计算百位上1出现的次数，它可能受到三方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字:

- 如果百位上数字为`0`，百位上可能出现1的次数由更高位决定。

  比如：`12013`，则可以知道百位出现1的情况可能是：`100~199, 1100~1199, 2100~2199, ... , 11100~11199`，一共`1200`个。可以看出是由更高位数字（`12`）决定，并且等于更高位数字（`12`）乘以 当前位数（`100`）。注意：高位数字不包括当前位

- 如果百位上数字为`1`，百位上可能出现1的次数不仅受更高位影响还受低位影响。
  
   比如：`12113`，则可以知道百位受高位影响出现的情况是：`100~199, 1100~1199, 2100~2199, ... , 11100~11199`，一共`1200`个。和上面情况一样，并且等于更高位数字（`12`）乘以 当前位数（`100`）。但同时它还受低位影响，百位出现`1`的情况是：`12100~12113`, 一共`14`个，等于低位数字（`13`）`+1`。 注意：低位数字不包括当前数字

- 如果百位上数字大于`1`（`2~9`），则百位上出现1的情况仅由更高位决定

   比如`12213`，则百位出现`1`的情况是：`100~199, 1100~1199, 2100~2199, ... , 11100~11199, 12100~12199`, 一共有`1300`个，并且等于更高位数字`+1`（`12+1`）乘以当前位数（`100`）



## 代码

```c++
class Solution {
public:
    int countDigitOne(int n) {
        int res = 0;
        long long count = 1;
        int num = n;
        while (n != 0) {
            int curr_num = n % 10;
            int lower_nums = num % count;
            n = n / 10;
            if (curr_num == 0) {
                res += n * count;
            } else if (curr_num == 1) {
                res += n * count + lower_nums + 1;
            } else {
                res += (n + 1) * count;
            }
            count *= 10;
        }
        return res;
    }
};
```

