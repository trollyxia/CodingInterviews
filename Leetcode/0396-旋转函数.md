# 396-旋转函数

难度 中等



## 题目描述

给定一个长度为 `n` 的整数数组 `A` 。

假设 `Bk` 是数组 `A` 顺时针旋转 `k` 个位置后的数组，我们定义 `A` 的“旋转函数” `F` 为：

`F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]`。

计算`F(0), F(1), ..., F(n-1)`中的最大值。

注意:
可以认为 `n` 的值小于 `10^5`。

示例:
```
A = [4, 3, 2, 6]

F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。
```


## 思路

看一下`F(1)`和`F(0)`的关系：
可以发现除了最后一项以外，其余项都比上一项前面的系数多一；
可以做一个小转换：（用pos存储最后一项的数组下标）
F(n)=F(n-1)+sum-n*nums[pos];



## 代码

```c++
class Solution {
public:
    int maxRotateFunction(vector<int>& nums) {
        int i;
        long long sum = 0;
        long long f = 0;
        for (i = 0; i < nums.size(); i++) {
            sum += nums[i];
            f += nums[i] * i;
        }
        int res = f;
        for (i = 1; i < nums.size(); i++) {
            f = f + sum - nums.size() * (nums[nums.size() - i]);
            if (f > res) res = f;
        }
        return res;
    }
};
```

