# 91-解码方法

难度 中等



## 题目描述

一条包含字母 `A-Z` 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```


给定一个只包含数字的**非空**字符串，请计算解码方法的总数。

题目数据保证答案肯定是一个 32 位的整数。

示例 1：

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

示例 2：

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

示例 3：

```
输入：s = "0"
输出：0
```

示例 4：

```
输入：s = "1"
输出：1
```

示例 5：

```
输入：s = "2"
输出：1
```

提示：

- `1 <= s.length <= 100`
- `s` 只包含数字，并且可能包含前导零。



## 思路

动态规划，但是需要注意分情况讨论

设`dp[i]`为`s[0..i]`的译码方法总数，则

- 若`s[i]`不为`'0'`而且`s[i-1]`不为`'0'`而且`s[i-1]s[i]`两位拼起来小于等于`26`，那么`dp[i]=dp[i-1]+dp[i-2]`。
- 若`s[i]`为`'0'`：
  - 如果`s[i-1]`不为`'0'`而且`s[i-1]s[i]`拼起来小于等于`26`，则`dp[i]=dp[i-2]`
  - 否则`dp[i] = 0`



## 代码

```c++
class Solution {
public:
    int numDecodings(string s) {
        if (s[0] == '0') return 0;
        vector<int> res;
        res.push_back(1);
        res.push_back(1);
        int i;
        for (i = 1; i < s.size(); i++) {
            int cur_res = 0;
            if (s[i] != '0') cur_res += res[i];
            int num = 10 * (int)(s[i - 1] - '0') + (int)(s[i] - '0');
            if (num <= 26 && s[i - 1] != '0') cur_res += res[i - 1];
            res.push_back(cur_res);
        }
        return res[res.size() - 1];
    }
};
```

