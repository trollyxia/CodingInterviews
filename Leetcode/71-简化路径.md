# 71-简化路径

难度 中等



## 题目描述

以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：[Linux / Unix中的绝对路径 vs 相对路径](https://blog.csdn.net/u011327334/article/details/50355600)

请注意，返回的规范路径必须始终以斜杠 `/` 开头，并且两个目录名之间必须只有一个斜杠 `/`。最后一个目录名（如果存在）不能以 `/` 结尾。此外，规范路径必须是表示绝对路径的最短字符串。

示例 1：
```
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```
示例 2：
```
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
```
示例 3：
```
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```
示例 4：
```
输入："/a/./b/../../c/"
输出："/c"
```
示例 5：
```
输入："/a/../../b/../c//.//"
输出："/c"
```
示例 6：
```
输入："/a//b////c/d//././/.."
输出："/a/b/c"
```



## 思路

利用栈实现。需要注意一些特殊情况：

- `...`代表一个路径名，例如，`"/..."`返回`"/..."`而不是`"/"`。
- 遇到`..`但目前栈中仅剩根目录，则根目录不能出栈。

在所有路径后统一添加`"/"`可以避免很多特殊情况的处理。



## 代码

```c++
class Solution {
public:
    string simplifyPath(string path) {
        path = path + '/';
        stack<string> s;
        int i = 0;
        if(path[i] == '/')
            i++;
        s.push("/");
        string tmp = "";
        for(i; path[i] != '\0'; i++){
            while(path[i] != '/'){
                tmp += path[i];
                i++;
            }
            if(tmp == "..") {
                if(s.top() == "/" && s.size() > 1) s.pop();
                if(s.size() > 1) s.pop();
                tmp = "";
                continue;
            }
            if(tmp == "."){
                tmp = "";
                continue;
            }
            if(tmp != ""){
                s.push(tmp);
                tmp = "";
            }
            if(s.top() == "/") continue;
            s.push("/");
        }
        if(s.size() > 1 && s.top() == "/") s.pop();
        string res = "";
        while(!s.empty()){
            res = s.top() + res;
            s.pop();
        }
        return res;
    }
};
```

