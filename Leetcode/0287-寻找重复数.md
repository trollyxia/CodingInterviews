# 287-寻找重复数

难度 中等



## 题目描述

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `1` 到 `n` 之间（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，找出 **这个重复的数** 。

示例 1：
```
输入：nums = [1,3,4,2,2]
输出：2
```
示例 2：
```
输入：nums = [3,1,3,4,2]
输出：3
```
示例 3：
```
输入：nums = [1,1]
输出：1
```
示例 4：
```
输入：nums = [1,1,2]
输出：1
```

提示：

- `2 <= n <= 3 * 10^4`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次


进阶：

- 如何证明 `nums` 中至少存在一个重复的数字?
- 你可以在不修改数组 `nums` 的情况下解决这个问题吗？
- 你可以只用常量级 `O(1)` 的额外空间解决这个问题吗？
- 你可以设计一个时间复杂度小于 `O(n^2)` 的解决方案吗？



## 思路

以下集中思路不符合题目的进阶要求：

1. 利用哈希表判断重复数字，违反了空间复杂度要求
2. 将原始数组排序，违反了不能修改数组的要求
3. 利用[0041-缺失的第一个正数](0041-缺失的第一个正数.md)（原地哈希）的思路，当两个数发现要放在同一个地方的时候，就发现了这个重复的元素，违反了不能修改数组的要求

符合进阶要求的思路：

快慢指针思想： `fast` 和 `slow` 是指针，`nums[slow]` 表示取指针对应的元素。注意 `nums` 数组中的数字都是在 `1` 到 `n` 之间的（在数组中进行游走不会越界），因为有重复数字的出现，所以这个游走必然是成环的， 环的入口就是重复的元素， 即按照寻找链表环入口的思路来做。



## 代码

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int fast = 0;
        int slow = 0;
        while (true) {
            fast = nums[nums[fast]];
            slow = nums[slow];
            if (fast == slow) break;
        }
        fast = 0;
        while (fast != slow) {
            fast = nums[fast];
            slow = nums[slow];
        }
        return fast;
    }
};
```

